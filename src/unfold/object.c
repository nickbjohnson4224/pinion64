/*
 * Copyright (C) 2012 Nick Johnson <nickbjohnson4224 at gmail.com>
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "object.h"
#include "log.h"

struct unfold_object_list *object_list = NULL;
struct unfold_object *pinion_image = NULL;

int init_object_list(void) {

	// use object list generated by bootloader
	if (!object_list) {
		return 1;
	}

	// TODO -- coalesce objects in memory

	// list objects
	for (uint32_t i = 0; i < object_list->count; i++) {
		uint32_t basel = object_list->entry[i].base;
		uint32_t baseh = object_list->entry[i].base >> 32;
		uint32_t limitl = (object_list->entry[i].base + object_list->entry[i].size);
		uint32_t limith = (object_list->entry[i].base + object_list->entry[i].size) >> 32;

		log(INFO, "object: [%x%x %x%x] (%d KB) name: %s", baseh, basel, limith, limitl,
			object_list->entry[i].size >> 10, object_list->entry[i].name);
	}

	// locate first pinion image
	for (uint32_t i = 0; i < object_list->count; i++) {
		if (object_list->entry[i].type == UNFOLD_OBJECT_PINION) {
			pinion_image = &object_list->entry[i];
			return 0;
		}
	}

	return 0;
}
